# Практика 5. Прикладной уровень

## Программирование сокетов.

### A. Почта и SMTP (7 баллов)

### 1. Почтовый клиент (2 балла)
Напишите программу для отправки электронной почты получателю, адрес
которого задается параметром. Адрес отправителя может быть постоянным. Программа
должна поддерживать два формата сообщений: **txt** и **html**. Используйте готовые
библиотеки для работы с почтой, т.е. в этом задании **не** предполагается общение с smtp
сервером через сокеты напрямую.

Приложите скриншоты полученных сообщений (для обоих форматов).

#### Демонстрация работы

![image](https://github.com/user-attachments/assets/e8ffc6c9-2d70-4668-80a4-f54aeb17984f)
![image](https://github.com/user-attachments/assets/ec40c90c-6c1c-4131-9bcf-fdd2a3ca30d8)
![image](https://github.com/user-attachments/assets/77a1a913-046b-43b2-8d71-d6db247eafd3)


### 2. SMTP-клиент (3 балла)
Разработайте простой почтовый клиент, который отправляет текстовые сообщения
электронной почты произвольному получателю. Программа должна соединиться с
почтовым сервером, используя протокол SMTP, и передать ему сообщение.
Не используйте встроенные методы для отправки почты, которые есть в большинстве
современных платформ. Вместо этого реализуйте свое решение на сокетах с передачей
сообщений почтовому серверу.

Сделайте скриншоты полученных сообщений.

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/4e200ba7-93a4-49b3-bc65-13bf4a61336f)


### 3. SMTP-клиент: бинарные данные (2 балла)
Модифицируйте ваш SMTP-клиент из предыдущего задания так, чтобы теперь он мог
отправлять письма с изображениями (бинарными данными).

Сделайте скриншот, подтверждающий получение почтового сообщения с картинкой.

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/3daaf96e-3af4-4417-8909-8f6bdb43dfb3)

---

_Многие почтовые серверы используют ssl, что может вызвать трудности при работе с ними из
ваших приложений. Можете использовать для тестов smtp сервер СПбГУ: mail.spbu.ru, 25_

### Б. Удаленный запуск команд (3 балла)
Напишите программу для запуска команд (или приложений) на удаленном хосте с помощью TCP сокетов.

Например, вы можете с клиента дать команду серверу запустить приложение Калькулятор или
Paint (на стороне сервера). Или запустить консольное приложение/утилиту с указанными
параметрами. Однако запущенное приложение **должно** выводить какую-либо информацию на
консоль или передавать свой статус после запуска, который должен быть отправлен обратно
клиенту. Продемонстрируйте работу вашей программы, приложив скриншот.

Например, удаленно запускается команда `ping yandex.ru`. Результат этой команды (запущенной на
сервере) отправляется обратно клиенту.

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/63f679e3-afc8-42cc-82b2-5378b3d259f1)
![image](https://github.com/user-attachments/assets/ea2e8d0f-6e53-402e-8c0e-b70891491fa2)


### В. Широковещательная рассылка через UDP (2 балла)
Реализуйте сервер (веб-службу) и клиента с использованием интерфейса Socket API, которая:
- работает по протоколу UDP
- каждую секунду рассылает широковещательно всем клиентам свое текущее время
- клиент службы выводит на консоль сообщаемое ему время

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/99323037-cb22-4320-9448-430e6e488dd3)

## Задачи

### Задача 1 (2 балла)
Рассмотрим короткую, $10$-метровую линию связи, по которой отправитель может передавать
данные со скоростью $150$ бит/с в обоих направлениях. Предположим, что пакеты, содержащие
данные, имеют размер $100000$ бит, а пакеты, содержащие только управляющую информацию
(например, флаг подтверждения или информацию рукопожатия) – $200$ бит. Предположим, что у
нас $10$ параллельных соединений, и каждому предоставлено $1/10$ полосы пропускания канала
связи. Также допустим, что используется протокол HTTP, и предположим, что каждый
загруженный объект имеет размер $100$ Кбит, и что исходный объект содержит $10$ ссылок на другие
объекты того же отправителя. Будем считать, что скорость распространения сигнала равна
скорости света ($300 \cdot 10^6$ м/с).
1. Вычислите общее время, необходимое для получения всех объектов при параллельных
непостоянных HTTP-соединениях
2. Вычислите общее время для постоянных HTTP-соединений. Ожидается ли существенное
преимущество по сравнению со случаем непостоянного соединения?

#### Решение

**1. Исходные данные и расчеты:**

*   Общая скорость канала: $R_{\text{канал}} = 150$ бит/с
*   Кол-во параллельных соединений: $N_{\text{соед}} = 10$
*   Скорость на одно соединение: $R = R_{\text{канал}} / N_{\text{соед}} = 150 / 10 = 15$ бит/с
*   Размер объекта данных: $L_{\text{дан}} = 100,000$ бит
*   Размер управляющего пакета: $L_{\text{упр}} = 200$ бит
*   Всего объектов: $1 + 10 = 11$
*   Скорость распространения: $s = 300 \cdot 10^6$ м/с
*   Длина линии: $d = 10$ м

Время передачи управляющего пакета:
$$T_{\text{упр}} = \frac{L_{\text{упр}}}{R} = \frac{200}{15} \approx 13.333 \text{ с}$$

Время передачи объекта данных:
$$T_{\text{дан}} = \frac{L_{\text{дан}}}{R} = \frac{100000}{15} \approx 6666.667 \text{ с}$$

Время распространения сигнала (в одну сторону):
$$T_p = \frac{d}{s} = \frac{10}{300 \cdot 10^6} \approx 3.333 \cdot 10^{-8} \text{ с}$$
Значение $T_p$ очень мало и на итоговые численные расчеты существенно не повлияет, но для точности учтем его в формулах.

Время на загрузку одного объекта с установкой нового TCP-соединения (3 управляющих пакета + пакет данных, каждый со своей задержкой распространения):
$$T_{\text{обНепост}} = 3(T_{\text{упр}} + T_p) + (T_{\text{дан}} + T_p) = 3T_{\text{упр}} + T_{\text{дан}} + 4T_p$$
$$T_{\text{обНепост}} \approx 3(13.333) + 6666.667 + 4T_p \approx 40 + 6666.667 + 4T_p \approx 6706.667 \text{ с} + 4T_p$$

**2. Параллельные непостоянные HTTP-соединения**

*   Загрузка базового HTML (1 объект):
    $T_{\text{HTML}} = T_{\text{обНепост}} \approx 6706.667 \text{ с} + 4T_p$
*   Параллельная загрузка 10 встроенных объектов (каждый по новому соединению, время определяется самым долгим, т.е. временем одного такого объекта):
    $T_{\text{10встр}} = T_{\text{обНепост}} \approx 6706.667 \text{ с} + 4T_p$
*   Общее время (последовательно: сначала HTML, потом параллельно встроенные):
    $$T_{\text{непост}} = T_{\text{HTML}} + T_{\text{10встр}} = 2 \cdot T_{\text{обНепост}}$$
    $$T_{\text{непост}} = 2 \cdot (3T_{\text{упр}} + T_{\text{дан}} + 4T_p) = 6T_{\text{упр}} + 2T_{\text{дан}} + 8T_p$$
    $$T_{\text{непост}} \approx 6(13.333) + 2(6666.667) + 8T_p \approx 80 + 13333.334 + 8T_p \approx 13413.334 \text{ с}$$
    ($8T_p \approx 2.67 \cdot 10^{-7}$ с - пренебрежимо мало).

**3. Постоянные HTTP-соединения**

*   Установка 10 TCP-соединений параллельно (время на установку одного: $2 \text{RTT}$ = $2(T_{\text{упр}} + T_p)$ ):
    $T_{\text{устTCP}} = 2T_{\text{упр}} + 2T_p \approx 2(13.333) + 2T_p \approx 26.666 \text{ с} + 2T_p$
*   Загрузка базового HTML по одному из соединений (1 запрос + 1 ответ):
    $T_{\text{загрHTML}} = (T_{\text{упр}} + T_p) + (T_{\text{дан}} + T_p) = T_{\text{упр}} + T_{\text{дан}} + 2T_p \approx 13.333 + 6666.667 + 2T_p \approx 6680 \text{ с} + 2T_p$
*   Параллельная загрузка 10 встроенных объектов по уже установленным соединениям (время определяется загрузкой одного объекта):
    $T_{\text{10встрПост}} = T_{\text{упр}} + T_{\text{дан}} + 2T_p \approx 6680 \text{ с} + 2T_p$
*   Общее время:
    $$T_{\text{пост}} = T_{\text{устTCP}} + T_{\text{загрHTML}} + T_{\text{10встрПост}} $$
    $$T_{\text{пост}} = (2T_{\text{упр}} + 2T_p) + (T_{\text{упр}} + T_{\text{дан}} + 2T_p) + (T_{\text{упр}} + T_{\text{дан}} + 2T_p)$$
    $$T_{\text{пост}} = 4T_{\text{упр}} + 2T_{\text{дан}} + 6T_p$$
    $$T_{\text{пост}} \approx 4(13.333) + 2(6666.667) + 6T_p \approx 53.332 + 13333.334 + 6T_p \approx 13386.666 \text{ с}$$
    ($6T_p \approx 2.00 \cdot 10^{-7}$ с - пренебрежимо мало).

**4. Сравнение и вывод**

$T_{\text{непост}} \approx 13413.334 \text{ с}$
$T_{\text{пост}} \approx 13386.666 \text{ с}$

Разница:
$\Delta T = T_{\text{непост}} - T_{\text{пост}} \approx 13413.334 - 13386.666 \approx 26.668 \text{ с}$
Это эквивалентно экономии $2T_{\text{упр}} + 2T_p$.

**Вывод:**
Постоянные HTTP-соединения дают выигрыш примерно в $26.67$ секунд. В данном сценарии с очень медленным каналом и большими объектами, это составляет лишь около $0.2\%$ от общего времени загрузки. Таким образом, существенного преимущества постоянные соединения **не дают**, так как основное время тратится на передачу самих данных, а не на установку соединений.

**1. Исходные данные и расчеты:**

*   Общая скорость канала: $R_{\text{канал}} = 150$ бит/с
*   Кол-во параллельных соединений: $N_{\text{соед}} = 10$
*   Скорость на одно соединение: $R = R_{\text{канал}} / N_{\text{соед}} = 150 / 10 = 15$ бит/с
*   Размер объекта данных: $L_{\text{дан}} = 100,000$ бит
*   Размер управляющего пакета: $L_{\text{упр}} = 200$ бит
*   Всего объектов: $1 + 10 = 11$
*   Скорость распространения: $s = 300 \cdot 10^6$ м/с
*   Длина линии: $d = 10$ м

Время передачи управляющего пакета:
$$T_{\text{упр}} = \frac{L_{\text{упр}}}{R} = \frac{200}{15} \approx 13.333 \text{ с}$$

Время передачи объекта данных:
$$T_{\text{дан}} = \frac{L_{\text{дан}}}{R} = \frac{100000}{15} \approx 6666.667 \text{ с}$$

Время распространения сигнала (в одну сторону):
$$T_p = \frac{d}{s} = \frac{10}{300 \cdot 10^6} \approx 3.333 \cdot 10^{-8} \text{ с}$$
Значение $T_p$ очень мало и на итоговые численные расчеты существенно не повлияет, но для точности учтем его в формулах.

Время на загрузку одного объекта с установкой нового TCP-соединения (3 управляющих пакета + пакет данных, каждый со своей задержкой распространения):
$$T_{\text{обНепост}} = 3(T_{\text{упр}} + T_p) + (T_{\text{дан}} + T_p) = 3T_{\text{упр}} + T_{\text{дан}} + 4T_p$$
$$T_{\text{обНепост}} \approx 3(13.333) + 6666.667 + 4T_p \approx 40 + 6666.667 + 4T_p \approx 6706.667 \text{ с} + 4T_p$$

**2. Параллельные непостоянные HTTP-соединения**

*   Загрузка базового HTML (1 объект):
    $T_{\text{HTML}} = T_{\text{обНепост}} \approx 6706.667 \text{ с} + 4T_p$
*   Параллельная загрузка 10 встроенных объектов (каждый по новому соединению, время определяется самым долгим, т.е. временем одного такого объекта):
    $T_{\text{10встр}} = T_{\text{обНепост}} \approx 6706.667 \text{ с} + 4T_p$
*   Общее время (последовательно: сначала HTML, потом параллельно встроенные):
    $$T_{\text{непост}} = T_{\text{HTML}} + T_{\text{10встр}} = 2 \cdot T_{\text{обНепост}}$$
    $$T_{\text{непост}} = 2 \cdot (3T_{\text{упр}} + T_{\text{дан}} + 4T_p) = 6T_{\text{упр}} + 2T_{\text{дан}} + 8T_p$$
    $$T_{\text{непост}} \approx 6(13.333) + 2(6666.667) + 8T_p \approx 80 + 13333.334 + 8T_p \approx 13413.334 \text{ с}$$
    ($8T_p \approx 2.67 \cdot 10^{-7}$ с - пренебрежимо мало).

**3. Постоянные HTTP-соединения**

*   Установка 10 TCP-соединений параллельно (время на установку одного: $2 \text{RTT}$ = $2(T_{\text{упр}} + T_p)$ ):
    $T_{\text{устTCP}} = 2T_{\text{упр}} + 2T_p \approx 2(13.333) + 2T_p \approx 26.666 \text{ с} + 2T_p$
*   Загрузка базового HTML по одному из соединений (1 запрос + 1 ответ):
    $T_{\text{загрHTML}} = (T_{\text{упр}} + T_p) + (T_{\text{дан}} + T_p) = T_{\text{упр}} + T_{\text{дан}} + 2T_p \approx 13.333 + 6666.667 + 2T_p \approx 6680 \text{ с} + 2T_p$
*   Параллельная загрузка 10 встроенных объектов по уже установленным соединениям (время определяется загрузкой одного объекта):
    $T_{\text{10встрПост}} = T_{\text{упр}} + T_{\text{дан}} + 2T_p \approx 6680 \text{ с} + 2T_p$
*   Общее время:
    $$T_{\text{пост}} = T_{\text{устTCP}} + T_{\text{загрHTML}} + T_{\text{10встрПост}} $$
    $$T_{\text{пост}} = (2T_{\text{упр}} + 2T_p) + (T_{\text{упр}} + T_{\text{дан}} + 2T_p) + (T_{\text{упр}} + T_{\text{дан}} + 2T_p)$$
    $$T_{\text{пост}} = 4T_{\text{упр}} + 2T_{\text{дан}} + 6T_p$$
    $$T_{\text{пост}} \approx 4(13.333) + 2(6666.667) + 6T_p \approx 53.332 + 13333.334 + 6T_p \approx 13386.666 \text{ с}$$
    ($6T_p \approx 2.00 \cdot 10^{-7}$ с - пренебрежимо мало).

**4. Сравнение и вывод**

$T_{\text{непост}} \approx 13413.334 \text{ с}$
$T_{\text{пост}} \approx 13386.666 \text{ с}$

Разница:
$\Delta T = T_{\text{непост}} - T_{\text{пост}} \approx 13413.334 - 13386.666 \approx 26.668 \text{ с}$
Это эквивалентно экономии $2T_{\text{упр}} + 2T_p$.

**Вывод:**
Постоянные HTTP-соединения дают выигрыш примерно в $26.67$ секунд. В данном сценарии с очень медленным каналом и большими объектами, это составляет лишь около $0.2\%$ от общего времени загрузки. Таким образом, существенного преимущества постоянные соединения **не дают**, так как основное время тратится на передачу самих данных, а не на установку соединений.

### Задача 2 (3 балла)
Рассмотрим раздачу файла размером $F = 15$ Гбит $N$ пирам. Сервер имеет скорость отдачи $u_s = 30$
Мбит/с, а каждый узел имеет скорость загрузки $d_i = 2$ Мбит/с и скорость отдачи $u$. Для $N = 10$, $100$
и $1000$ и для $u = 300$ Кбит/с, $700$ Кбит/с и $2$ Мбит/с подготовьте график минимального времени
раздачи для всех сочетаний $N$ и $u$ для вариантов клиент-серверной и одноранговой раздачи.

#### Решение
![image](https://github.com/user-attachments/assets/684ea482-6292-46f1-a614-5bd33365ed22)

### Задача 3 (3 балла)
Рассмотрим клиент-серверную раздачу файла размером $F$ бит $N$ пирам, при которой сервер
способен отдавать одновременно данные множеству пиров – каждому с различной скоростью,
но общая скорость отдачи при этом не превышает значения $u_s$. Схема раздачи непрерывная.
1. Предположим, что $\dfrac{u_s}{N} \le d_{min}$.
   При какой схеме общее время раздачи будет составлять $\dfrac{N F}{u_s}$?
2. Предположим, что $\dfrac{u_s}{N} \ge d_{min}$. 
   При какой схеме общее время раздачи будет составлять  $\dfrac{F}{d_{min}}$?
3. Докажите, что минимальное время раздачи описывается формулой $\max\left(\dfrac{N F}{u_s}, \dfrac{F}{d_{min}}\right)$?

#### Решение
Минимальное время раздачи $D$ в клиент-серверной модели ограничено двумя факторами:
1.  Общей пропускной способностью сервера: сервер должен передать $N$ копий файла, общий объем $NF$. Время не может быть меньше $D_1 = \frac{NF}{u_s}$.
2.  Скоростью загрузки самого медленного пира: ни один пир не может загрузить файл быстрее, чем за $D_2 = \frac{F}{d_{\text{min}}}$.

Таким образом, минимальное время раздачи $D = \max(D_1, D_2) = \max\left(\frac{NF}{u_s}, \frac{F}{d_{\text{min}}}\right)$.

Рассмотрим два случая, чтобы показать достижимость этого времени.

**1. Случай: $\dfrac{u_s}{N} \le d_{\text{min}}$**

Это неравенство эквивалентно $\frac{NF}{u_s} \ge \frac{F}{d_{\text{min}}}$.
Следовательно, в этом случае $\max\left(\frac{NF}{u_s}, \frac{F}{d_{\text{min}}}\right) = \frac{NF}{u_s}$.

*   **Схема раздачи:** Сервер делит свою скорость $u_s$ поровну между $N$ пирами. Каждый пир $i$ получает данные со скоростью $a_i = \frac{u_s}{N}$.
*   **Корректность:**
    *   $\sum a_i = N \cdot \frac{u_s}{N} = u_s$, что не превышает возможности сервера.
    *   $a_i = \frac{u_s}{N} \le d_{\text{min}} \le d_i$ для каждого пира $i$. Скорость не превышает возможности загрузки пиров.
*   **Время раздачи:** Для каждого пира $T_i = \frac{F}{a_i} = \frac{F}{u_s/N} = \frac{NF}{u_s}$.
    Общее время $D = \frac{NF}{u_s}$, что и требовалось.

**2. Случай: $\dfrac{u_s}{N} \ge d_{\text{min}}$**

Это неравенство эквивалентно $\frac{NF}{u_s} \le \frac{F}{d_{\text{min}}}$.
Следовательно, в этом случае $\max\left(\frac{NF}{u_s}, \frac{F}{d_{\text{min}}}\right) = \frac{F}{d_{\text{min}}}$.

*   **Схема раздачи:** Сервер отдает каждому пиру $i$ данные со скоростью $a_i = d_{\text{min}}$.
*   **Корректность:**
    *   Суммарная требуемая скорость от сервера: $\sum a_i = N \cdot d_{\text{min}}$. Из условия $\frac{u_s}{N} \ge d_{\text{min}} \implies u_s \ge N d_{\text{min}}$. Таким образом, серверу хватает пропускной способности ($N d_{\text{min}} \le u_s$).
    *   $a_i = d_{\text{min}} \le d_i$ для каждого пира $i$. Скорость не превышает возможности загрузки пиров.
*   **Время раздачи:** Для каждого пира $T_i = \frac{F}{a_i} = \frac{F}{d_{\text{min}}}$.
    Общее время $D = \frac{F}{d_{\text{min}}}$, что и требовалось.

**3. Доказательство формулы $\max\left(\dfrac{N F}{u_s}, \dfrac{F}{d_{\text{min}}}\right)$**

Мы установили, что любое время раздачи $D$ должно быть $D \ge \frac{NF}{u_s}$ и $D \ge \frac{F}{d_{\text{min}}}$.
Следовательно, $D \ge \max\left(\frac{NF}{u_s}, \frac{F}{d_{\text{min}}}\right)$.

В пунктах 1 и 2 мы рассмотрели две взаимоисключающие и исчерпывающие ситуации:
*   Когда $\frac{NF}{u_s}$ является большим из двух членов, мы показали, что время $\frac{NF}{u_s}$ достижимо.
*   Когда $\frac{F}{d_{\text{min}}}$ является большим из двух членов, мы показали, что время $\frac{F}{d_{\text{min}}}$ достижимо.

Таким образом, значение, даваемое формулой $\max\left(\frac{NF}{u_s}, \frac{F}{d_{\text{min}}}\right)$, всегда является достижимым минимальным временем раздачи.
