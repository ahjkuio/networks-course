# Практика 10. Сетевой уровень

## Wireshark: IP (8 баллов)
Для работы вам понадобится программа traceroute. При работе программа traceroute сначала
отправляет одну или несколько дейтаграмм, причем в поле предписанного времени жизни (TTL) в
IP-заголовке таких дейтаграмм устанавливается значение 1; затем программа посылает одну или
несколько дейтаграмм по тому же адресу, но в поле TTL уже ставится значение 2; далее процесс
повторяется с изменением значения TTL на 3 и т. д.

Маршрутизатор должен уменьшать на единицу значение в поле TTL каждой дейтаграммы,
которую получает. Если значение в поле TTL достигает 0, маршрутизатор возвращает 
ICMP-сообщение (тип 11 – значение TTL исчерпано) хосту-отправителю.

Таким образом хост, на котором выполняется программа traceroute, может узнать
идентификационные данные всех маршрутизаторов между собой и хостом назначения X. Для
этого ему достаточно свериться с IP-адресами источников дейтаграмм, содержащих сообщения
протокола ICMP о том, что их значение TTL достигло нуля.

Вам необходима версия программы traceroute, которая умеет рассылать дейтаграммы разной длины.
- Если вы работаете с Windows:
  Программа tracert, предоставляемая в Windows, не позволяет изменять размер сообщения 
  эхо-запроса ICMP (ping), посылаемого программой tracert. Для этого используйте программу
  [pingplotter](https://www.pingplotter.com/). Размер сообщения ICMP с эхо-запросом можно установить явно,
  выбрав команду меню Edit => Options => Default Settings => Engine, а затем указав значение в поле
  Packet Size.
- Если вы работаете с Unix:
  При помощи команды traceroute из операционных систем Unix можно явно устанавливать размер
  UDP-дейтаграммы, отправляемой на хост назначения (в Unix системах вместо ICMP используется
  UDP). Это значение вводится в командную строку traceroute сразу же за именем или адресом
  хоста назначения. Например, чтобы отправить дейтаграммы traceroute размером 2000 байт на
  адрес gaia.cs.umass.edu, может использоваться следующая команда:
  `traceroute gaia.cs.umass.edu 2000`

#### Подготовка
1. Запустите программу Wireshark и начните захват пакетов.
2. Запустите pingplotter, выберите имя какого-либо целевого хоста (например, akamai.com).
   Запустите трассировку для размера пакета Packet Size = 56 байт.
3. Остановите трассировку Wireshark.

#### Вопросы
В вашей трассе вы должны видеть ряд эхо-запросов по протоколу ICMP (при работе с
Windows) или UDP-сегмент (в случае с Unix).
1. Выберите первое ICMP-сообщение эхо-запроса, отправленное вашим компьютером, и
   раскройте часть информации о пакете Internet Protocol в окне подробной информации.
   Каков IP-адрес вашего компьютера?
   - 192.168.1.96
   - ![image](https://github.com/user-attachments/assets/8030b2d1-f987-4fda-8fd9-670892ea3306)

2. Найдите заголовок IP-пакета. Какое значение указано здесь в поле протокола верхнего уровня?
   - UDP (17)
   - ![image](https://github.com/user-attachments/assets/5c0fc523-ae12-461a-ba8c-c376892d54f6)
3. Сколько байт в IP-заголовке? Сколько байт приходится на полезную нагрузку IP-дейтаграммы?
   - ![image](https://github.com/user-attachments/assets/bd26061d-2b72-47bd-a475-df8ac58612cc)
   - 20 байт
   - 56 - 20 = 36 байт
4. Отсортируйте отслеженные пакеты по их исходному IP-адресу; для этого щелкните по
   заголовку столбца Source. Выберите первое сообщение эхо-запроса, отосланное
   вашим компьютером по протоколу ICMP, и раскройте раздел Internet Protocol.
   1. Какие поля IP-дейтаграммы всегда изменяются от одной дейтаграммы к
      следующей в рамках одной последовательности ICMP-сообщений, отсылаемых
      компьютером (последовательность – это все сообщения, которые отправляются до конечного хоста)?
   - ![image](https://github.com/user-attachments/assets/b670701d-5875-4be1-85e1-d1fd8a559809)
   - Identification, TTL, Header Checksum
   3. Какие поля не меняются? Какие поля должны оставаться неизменными? Какие
      поля должны изменяться? (в рамках одного запуска утилиты)
      - Version, Header Length, Differentiated Services Field, Total Length, Flags, Fragment Offset, Protocol, Source Address, Destination Address
      - Version, Header Length, Differentiated Services Field, Total Length, Flags, Fragment Offset, Protocol, Source Address, Destination Address
      - Time to Live (по логике работы traceroute), Header Checksum (так как TTL меняется). Поле Identification также обычно меняется.
   4. Как изменяется значение поля Identification IP-дейтаграммы с каждым
      последующим эхо-запросом? Есть ли какая-либо закономерность?
      - Поле Identification изменяется для каждого нового UDP-запроса traceroute (наблюдаемые значения: 0xad45, 0x86c8, 0xf572 0xc086
      - ОС назначает эти ID для уникальной идентификации IP-пакетов; алгоритм генерации может не быть строго последовательным.
5. Какое значение содержится в поле Identification (Идентификация), а какое – в поле TTL
   (выберите какой-либо один пакет ICMP)?
   - Identification: 0xad45 (44357)
   - 1
   - ![image](https://github.com/user-attachments/assets/26645b4d-3d4f-4ab2-9c7c-eb3e1fa75523)

6. Остаются ли эти значения (Identification и TTL) неизменными во всех сообщениях
   протокола ICMP, где содержится информация об истечении предписанного времени
   жизни; рассмотрите только те из таких сообщений, которые поступили на компьютер с
   ближайшего (первого транзитного) маршрутизатора.
   - TTL: Да, остается неизменным
   - Identification: Нет, не остается неизменным.
7. Найдите серии откликов ICMP, в которых содержатся сообщения об истечении
   предписанного времени жизни (time-to-live exceeded). Выберите один из пакетов.
   Какое значение содержится в поле Identification (Идентификация), а какое – в поле TTL?
   - Identification: 0x0000 (0)
   - Time to Live: 248
   - ![image](https://github.com/user-attachments/assets/b3851fdc-ea6d-4bbe-a6df-b05de7615d5f)

8. **Фрагментация**. Остановите захват пакетов в Wireshark. Измените размер пакета
   Packet Size = 3500 байт. Снова запустите захват пакетов в Wireshark и перезапустите
   трассировку. (Для Unix заново запустите traceroute с длиной пакета 3500 байт).
   Найдите первое сообщение протокола ICMP с эхо-запросом, поступившее на ваш
   компьютер (с уже измененным размером пакета).
   1. Было ли это сообщение фрагментировано между двумя или более IP-дейтаграммами? 
      Если да, то сколько фрагментов было создано?
      - 3
   2. Какие поля IP-заголовка изменяются в разных фрагментах?
      - Total Length, Flags, Fragment Offset, Header Checksum
      - ![image](https://github.com/user-attachments/assets/0bcf6c82-4620-4488-9449-08cdac3fc68e)

## Программирование.

### 1. Эхо-запросы через ICMP (8 баллов)
Реализуйте консольное приложение для эхо-запросов (пингования) с помощью ICMP-запросов и
ответов. Приложение отправляет ICMP-пакеты («эхо-запрос» или «пинг») на целевой хост и
слушает ICMP-ответы («эхо-ответ») от него. Обычно при получении ответов измеряется время
оборота (RTT), фиксируются потери пакетов и выводится статистическая сводка о полученных
ответах (минимальное, максимальное и среднее значение времени оборота, а в некоторых
версиях еще и стандартное отклонение от среднего).

Вам потребуется написать только клиентскую часть программы, а функциональные возможности,
необходимые на стороне сервера, встроены почти во все операционные системы.
Приложение должно отправлять эхо-запросы на определенный хост через одну секунду. Каждое
такое сообщение-запрос содержит данные, которые включают в себя отметку времени. После
отправки каждого пакета приложение ждет получения ответного сообщения в течение одной
секунды. Если ответа нет, то клиент предполагает, что пакет запроса или ответный пакет
были потеряны в сети (или целевой хост недоступен).

В этой работе необходимо будет разобраться с тем, как организовать проверку контрольных сумм
и создание заголовков для ICMP пакетов.

### Задание А (6 баллов)
Реализуйте приложение для эхо-запросов (пингования) с помощью ICMP-запросов и ответов.

Сделайте скриншоты результатов пингования **двух различных** хостов назначения, находящихся
**на разных континентах**.

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/dff99563-a62a-4e98-8fbd-1098bac1c777)


### Задание Б (1 балл)
Организуйте вывод на консоль так, как это сделано в стандартной утилите ping: нужно вывести
минимальное, максимальное и среднее значение RTT в конце каждого ответа от сервера.
Дополнительно вычислите коэффициент потери пакетов (в процентах).

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/06b53c64-b6c1-4302-9884-62db8e5a08ea)


### Задание В (1 балл)
Ваша программа обрабатывает только тайм-ауты в получении ICMP-ответов. Добавьте к ней
функционал анализа кодов ошибок протокола ICMP и вывод соответствующих результатов для
пользователя. Примерами кодов ошибок ICMP являются: 0 – сеть назначения недоступна, 1 – хост
назначения недоступен.

Приложите скриншот вывода одной из ошибок.

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/049b52a0-0e67-46c0-bc27-b64c9e2dd933)


### Справочная информация о протоколе ICMP

#### ICMP-заголовок

<table>
    <thead>
        <tr>
            <th>Биты</th>
            <th>160-167</th>
            <th>168-175</th>
            <th>176-183</th>
            <th>184-191</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td align="center"><b>160</B></td>
            <td align="center">Тип</td>
            <td align="center">Код</td>
            <td align="center" colspan=2>Контрольная сумма</td>
        </tr>
        <tr>
            <td align="center"><b>192</b></td>
            <td align="center" colspan=2>Идентификатор</td>
            <td align="center" colspan=2>Номер последовательности</td>
        </tr>
    </tbody>
</table>

ICMP-заголовок начинается после 160-го бита IP-заголовка
- Тип – тип сообщения ICMP
- Код – подтип заданного типа
- Контрольная сумма – вычисляемые для всего ICMP-пакета целиком данные для проверки
ошибок. При вычислении контрольной суммы значение поля полагается равным нулю
- Идентификатор – значение, возвращаемое в случае, когда сообщение является эхо-ответом
- Номер последовательности – значение, возвращаемое в случае, когда сообщение является
эхо-ответом

#### Эхо-запрос
Эхо-запрос – это сообщение ICMP, данные которого должны быть возвращены обратно в эхо-ответе от принимающего хоста.
- Тип ICMP для эхо-запроса равен 8.
- Код устанавливается в значение 0.
- Идентификатор и номер последовательности используются клиентом, чтобы
идентифицировать соответствующие друг другу пары запрос-ответ. На практике
большинство систем семейства Linux используют уникальный идентификатор для каждого
процесса пингования, а номер последовательности – увеличивающееся в течение этого
процесса число.
- Данные, полученные в эхо-запросе, должны полностью быть включены в эхо-ответ.

#### Эхо-ответ
Эхо-ответ – это сообщение ICMP, генерируемое в ответ на эхо-запрос.
- Тип ICMP и код для эхо-ответа устанавливаются в 0.
- Идентификатор и номер последовательности используются клиентом для определения
соответствия пар запрос-ответ.
- Данные, полученные в эхо-запросе, должны полностью быть включены в эхо-ответ.

### 2. Go back-N протокол (8 баллов)
Реализуйте протокол конвейерной передачи данных GBN. Продемонстрируйте работоспособность
вашего решения на примере консольного клиент-серверного приложения, в котором клиент
отправляет серверу файл с данными. Основные шаги при передаче и получении пакетов должны
выводиться в лог. По логу должно быть видно состояние клиента/сервера: какие пакеты находятся
в окне передачи, на какие получены подтверждения, на какие еще нет, а какие еще не переданы.

Приложите файлы с логами клиента и сервера или скрин работы программы.

Пример вывода на консоль приложения, которое было рассмотрено на практике: 

<img src="images/go-back-n.png" width=700 />

#### Демонстрация работы
![image](https://github.com/user-attachments/assets/7fcfd9fa-99e4-4a47-9ddf-6df348efd9b2)
![image](https://github.com/user-attachments/assets/207cd533-62d1-41fd-ae7f-56eb6a0f5be7)

