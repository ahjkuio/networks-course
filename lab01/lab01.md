# Практика 1. Wireshark: HTTP
Эта работа исследует несколько аспектов протокола HTTP: базовое взаимодействие GET/ответ,
форматы сообщений HTTP, получение больших файлов HTML, получение файлов HTML со
встроенными объектами, а также проверку подлинности и безопасность HTTP.

Во всех заданиях (а также во всех следующих лабах) предполагается, что вы к своему ответу 
приложите **подтверждающий скрин** программы Wireshark (достаточно одного скрина на задание).

## Задание 1. Базовое взаимодействие HTTP GET/response (2 балла)

#### Подготовка
1. Запустите веб-браузер.
2. Запустите анализатор пакетов Wireshark, но пока не начинайте захват пакетов. Введите
   «http» в окне фильтра, чтобы позже в окне списка пакетов отображались только захваченные сообщения HTTP.
3. Подождите несколько секунд, а затем начните захват пакетов Wireshark.
4. Введите в браузере адрес: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html.  
   Ваш браузер должен отобразить очень простой однострочный HTML-файл.
5. Остановите захват пакетов Wireshark.

#### Вопросы
1. Использует ли ваш браузер HTTP версии 1.0 или 1.1? Какая версия HTTP работает на
   сервере?
   - Версия HTTP моего браузера - 1.1 ![image](https://github.com/user-attachments/assets/39810634-e4bb-4e7e-8d1b-e3b67b99151e)
   - Версия HTTP сервера - 1.1 ![image](https://github.com/user-attachments/assets/490f0a49-cd4c-4459-a9b3-f4519de7a8a8)
2. Какие языки (если есть) ваш браузер может принимать? В захваченном сеансе какую еще информацию (если есть) браузер предоставляет серверу относительно пользователя/браузера?
   - ru-RU: Русский язык (Россия). Это самый предпочтительный язык (q=1.0 - если не указано q, то подразумевается 1.0, наивысший приоритет).
ru: Русский язык (без указания региона). Второй по приоритету (q=0.9).
en-US: Английский язык (США). Третий по приоритету (q=0.8).
en: Английский язык (без указания региона). Четвертый по приоритету (q=0.7).
![image](https://github.com/user-attachments/assets/ab88f67c-823e-4331-b0c6-52693d9640fc)
   - User-agent сообщает серверу, что используется браузер Google Chrome версии 133, работающий в ОС Linux x86_64. Также указывается, что браузер использует движок рендеринга WebKit.
![image](https://github.com/user-attachments/assets/069dab88-a4b5-4770-8912-29c1f122c29a)

3. Какой IP-адрес вашего компьютера? Какой адрес сервера gaia.cs.umass.edu?
   - IP-адрес моего компьютера: В захваченном пакете HTTP GET запроса, IP-адрес моего компьютера указан как источник (Source). Это адрес: 192.168.1.97.
   - IP-адрес сервера gaia.cs.umass.edu: В том же пакете HTTP GET запроса, IP-адрес сервера gaia.cs.umass.edu указан как назначение (Destination). Это адрес: 128.119.245.12.
     ![image](https://github.com/user-attachments/assets/553282d2-802f-419f-9f07-c3f6cf274181)

4. Какой код состояния возвращается с сервера на ваш браузер?
   - Код состояния HTTP, возвращенный сервером, можно увидеть в пакете ответа сервера. В строке "Info" этого пакета указано: HTTP/1.1 304 Not Modified.
   - Код состояния 304 Not Modified означает, что запрошенный ресурс не был изменен с момента последнего запроса браузера. Сервер сообщает браузеру, что браузер может использовать кэшированную версию файла. В этом случае сервер не отправляет содержимое файла снова, чтобы сэкономить трафик. Далее я очищу Кэш браузера и буду работать с пакетом "200 OK"
   ![image](https://github.com/user-attachments/assets/b0147cf0-8813-48e9-9260-5c90477b64d0)

5. Когда HTML-файл, который вы извлекаете, последний раз модифицировался на сервере?
   - в полученном нами ответе с кодом состояния 304 Not Modified, сервер не прислал заголовок Last-Modified.

Это связано с тем, что при ответе 304 Not Modified сервер не передает содержимое файла, и многие заголовки, включая Last-Modified, могут быть опущены, так как браузер должен использовать кэшированную версию файла, у которой уже есть информация о времени последней модификации.

Чтобы узнать время последней модификации файла, нужно было бы получить ответ с кодом состояния 200 OK. Почистим кэш, перезайдем на ресурс и получим нужные нам данные:
Last-Modified: Sat, 22 Feb 2025 06:59:01 GMT\r\n
![image](https://github.com/user-attachments/assets/2974f95a-aedf-454c-aff6-b0eda2cd3f5e)

6. Сколько байтов контента возвращается вашему браузеру?
   - Сервер вернул моему браузеру 128 байт контента
![image](https://github.com/user-attachments/assets/0983d7c6-632b-40f5-a025-2cc413e41594)


## Задание 2. HTTP CONDITIONAL GET/response (2 балла)
Большинство веб-браузеров выполняют кэширование объектов и, таким образом, выполняют
условный GET при извлечении объекта HTTP. Прежде чем выполнять описанные ниже шаги, 
убедитесь, что кеш вашего браузера пуст.

#### Подготовка
1. Запустите веб-браузер и убедитесь, что кэш браузера очищен.
2. Запустите анализатор пакетов Wireshark.
3. Введите следующий URL-адрес в адресную строку браузера:
   http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html.  
   Ваш браузер должен отобразить очень простой пятистрочный HTML-файл.
4. Введите тот же URL-адрес в браузер еще раз (или просто нажмите кнопку обновления в
   браузере).
5. Остановите захват пакетов Wireshark и введите «http» в окне фильтра, чтобы в окне списка
   пакетов отображались только захваченные HTTP-сообщения.

#### Вопросы
1. Проверьте содержимое первого HTTP-запроса GET. Видите ли вы строку «IF-MODIFIED-SINCE» в HTTP GET?
   - В первом запросе GET, после очистки кэша, заголовок If-Modified-Since ОТСУТСТВУЕТ. Браузер делает обычный GET запрос, так как у него нет информации о предыдущей версии файла
   ![image](https://github.com/user-attachments/assets/357da885-34aa-478b-be75-78921579b375)

2. Проверьте содержимое ответа сервера. Вернул ли сервер содержимое файла явно? Как вы
   это можете увидеть?
   - Сочетание кода состояния 200 OK, наличия секции "Line-Based Text Data" с HTML-кодом, и  заголовков Content-Length и Content-Type: text/html показывают, что сервер в ответ на первый GET запрос явно вернул содержимое файла HTTP-wireshark-file2.html.
   ![image](https://github.com/user-attachments/assets/8e5f41f7-408d-4599-a52a-265fa3a7dfc7)

3. Теперь проверьте содержимое второго HTTP-запроса GET (из вашего браузера на сторону
   сервера). Видите ли вы строку «IF-MODIFIED-SINCE» в HTTP GET? Если да, то какая
   информация следует за заголовком «IF-MODIFIED-SINCE»?
   - Да, во втором HTTP GET запросе к файлу присутствует заголовок "If-Modified-Since".
   - Информация, которая следует за заголовком "If-Modified-Since", представляет собой дату и время. Эта дата и время указывают, когда, по мнению браузера, последний раз модифицировался запрошенный файл на сервере. Кажется, что браузер берет эту дату и время из заголовка "Last-Modified", который сервер прислал в ответе на первый GET запрос.
     ![image](https://github.com/user-attachments/assets/ce54c259-afa8-4529-a29c-31983e25de96)

4. Какой код состояния HTTP и фраза возвращаются сервером в ответ на этот второй запрос
   HTTP GET? Вернул ли сервер явно содержимое файла?
   - В ответ на второй HTTP GET запрос, сервер возвращает код состояния HTTP 304 Not Modified.
   - Сервер НЕ вернул явно содержимое файла в ответе на второй запрос. После заголовков HTTP ответа нет секции "Line-Based Text Data", отсутствие Content-Length. Мы просто получили файл из кеша.
     ![image](https://github.com/user-attachments/assets/4534eb06-3ffa-499a-b751-440c7fe80f71)


## Задание 3. Получение длинных документов (2 балла)

#### Подготовка
1. Запустите веб-браузер и убедитесь, что кэш браузера очищен.
2. Запустите анализатор пакетов Wireshark.
3. Введите следующий URL-адрес в адресную строку браузера:
   http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html  
   В браузере должен отобразиться довольно длинный текст.
4. Остановите захват пакетов Wireshark и введите «http» в окне фильтра.

#### Вопросы
1. Сколько сообщений HTTP GET отправил ваш браузер? Какой номер пакета в трассировке
   содержит сообщение GET?
   - Мой браузер отправил Один HTTP GET-запрос на сервер. Пакет с GET, имеет номер 254.
   ![image](https://github.com/user-attachments/assets/867ff1de-e74a-4656-8a2c-2e9efc744c1e)


2. Какой номер пакета в трассировке содержит код состояния и фразу, связанные с ответом
   на HTTP-запрос GET?
   - Пакет, содержащий код состояния и фразу, отправленный сервером в ответ на GET, имеет номер 260.
![image](https://github.com/user-attachments/assets/be093e06-49a2-411f-9a5b-db5cfa66a955)


3. Сколько сегментов TCP, содержащих данные, потребовалось для передачи одного HTTP ответа?
   - ![image](https://github.com/user-attachments/assets/86d21d80-51dc-4fc0-bf10-8df8ff59c3f3)
   - Пакеты 250-253: Это стандартное установление TCP-соединения (three-way handshake). Len=0 в Info в этих пакетах означает, что они не несут данных приложения.
Пакет 254: HTTP GET запрос от твоего браузера к серверу. Len=549 - это размер HTTP запроса.
Пакет 259: TCP ACK от сервера к клиенту. Len=0 - подтверждение получения данных, не содержит данных приложения.
Пакет 260: HTTP 200 OK ответ от сервера к клиенту. Len=4927 - это размер всего пакета, включая заголовки TCP/IP. Если посмотреть на детали пакета 260, там указано: TCP payload (4861 bytes) и Content-Length: 4500. Это означает, что данные HTTP в этом пакете составляют ~4861 байт, а само тело HTTP ответа (без заголовков HTTP) - 4500 байт.
![image](https://github.com/user-attachments/assets/5d9eb686-0957-43cb-8d59-54bba482f45a)
Пакет 262: TCP ACK от клиента к серверу. Len=0 - подтверждение получения данных из пакета 260.
Пакеты 292, 293, 311, 313: Это завершение TCP-соединения (TCP connection termination) с помощью FIN и ACK. Len=0 - не содержат данных приложения.
   - Следовательно, судя по моей трассировке TCP stream, для передачи HTTP ответа потребовался ОДИН TCP сегмент, содержащий данные (пакет 260)
     
5. Есть ли в передаваемых данных какая-либо информация заголовка HTTP, связанная с
   сегментацией TCP?
   - В заголовках HTTP присутствует информация, связанная с сегментацией TCP. Основным таким заголовком является Content-Length. В пакете HTTP ответа (пакет 260) заголовок Content-Length: 4500 указывает, что тело HTTP ответа имеет размер 4500 байт.
Content-Length информирует TCP о размере данных и связан с процессом сегментации, хотя и не контролирует его, то есть HTTP заголовок Content-Length не управляет процессом сегментации TCP. Сегментация TCP - это внутренняя работа протокола TCP, которая зависит от множества факторов (MSS - Maximum Segment Size, состояние сети, Congestion Control и т.п.). Content-Length лишь предоставляет информацию о размере данных, которые TCP должен доставить, и TCP учитывает эту информацию при своей работе, включая сегментацию.
![image](https://github.com/user-attachments/assets/26e03e40-89e9-4cf0-8e8d-2f972104d91f)

## Задание 4. HTML-документы со встроенными объектами (2 балла)
Исследуйте, что происходит, когда ваш браузер загружает файл со встроенными объектами, т. е. файл, 
включающий в себя другие объекты (в данном примере это файлы и картинки),
которые хранятся на другом сервере (серверах).

#### Подготовка
1. Запустите веб-браузер и убедитесь, что кэш браузера очищен.
2. Запустите анализатор пакетов Wireshark.
3. Введите следующий URL-адрес в адресную строку браузера:
   http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html.  
   Ваш браузер должен отобразить HTML-файл с двумя изображениями. На эти два изображения есть ссылки в
   базовом файле HTML. То есть сами изображения не содержатся в HTML, вместо этого URL-
   адреса изображений содержатся в загруженном файле HTML. Ваш браузер должен
   получить эти изображения с указанных веб-сайтов.
4. Остановите захват пакетов Wireshark и введите «http» в окне фильтра.

#### Вопросы
1. Сколько HTTP GET запросов было отправлено вашим браузером? На какие интернет-адреса были отправлены эти GET-запросы?
   - Мой браузер отправил 3 HTTP GET запроса.
Первый GET запрос (пакет 276) был отправлен на интернет-адрес gaia.cs.umass.edu для получения HTML-файла /wireshark-labs/HTTP-wireshark-file4.html. ([Full request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html], Destination Address: 128.119.245.12)
Второй GET запрос (пакет 299) был отправлен на интернет-адрес gaia.cs.umass.edu для получения изображения pearson.png. ([Full request URI: http://gaia.cs.umass.edu/pearson.png], Destination Address: 128.119.245.12)
Третий GET запрос (пакет 303) был отправлен на интернет-адрес kurose.cslash.net для получения изображения /8E_cover_small.jpg. ([Full request URI: http://kurose.cslash.net/8E_cover_small.jpg], Destination Address: 178.79.137.164)
![image](https://github.com/user-attachments/assets/9fc5d318-dd64-4daf-a316-a30e27c256ba)

2. Можете ли вы сказать, загрузил ли ваш браузер два изображения последовательно или
   они были загружены с веб-сайтов параллельно? Объясните.
   - Мой браузер загрузил изображения Параллельно.
     Временные метки ключевых пакетов из трассировки:

Запрос pearson.png (пакет 299): 14.065 секунды
Запрос /8E_cover_small.jpg (пакет 303): 14.141 секунды
Ответ pearson.png (пакет 304): 14.207 секунды
Ответ 301 на /8E_cover_small.jpg (пакет 307): 14.214 секунды

Запросы на изображения были отправлены с небольшой задержкой. Однако, ответы на оба запроса (пакеты 304 и 307) пришли практически одновременно (разница всего ~0.007 секунды). Браузер не ждал полного ответа на первый запрос, прежде чем начать получать ответ на второй. Серверы отдавали ресурсы браузеру параллельно, что позволяет значительно ускорить загрузку страницы. 
![image](https://github.com/user-attachments/assets/a551d718-1a73-47bf-919f-60399e617bb7)

## Задание 5. HTTP-аутентификация (2 балла)
Запустите веб-сайт, защищенный паролем, и исследуйте последовательность HTTP-сообщений, которыми обмениваются такие сайты.

#### Подготовка
1. Убедитесь, что кеш вашего браузера очищен.
2. Запустите анализатор пакетов Wireshark.
3. Введите следующий URL-адрес в адресную строку браузера:
   http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html
4. Введите требуемые имя пользователя и пароль во всплывающем окне  
   (Имя пользователя — «wireshark-students», пароль — «network»).
5. Остановите захват пакетов Wireshark и введите «http» в окне фильтра

#### Вопросы
1. Каков ответ сервера (код состояния и фраза) в ответ на начальное HTTP-сообщение GET от вашего браузера?
   - Ответ сервера на начальное HTTP-сообщение GET от моего браузера - 401 Unauthorized. Сервер отклонил первоначальный запрос, так как не были предоставлены учетные данные.
    ![image](https://github.com/user-attachments/assets/feeaf606-4c35-44f3-8650-3cd28735d40e)

2. Когда ваш браузер отправляет сообщение HTTP GET во второй раз, какое новое поле включается в сообщение HTTP GET?
   - Во втором HTTP GET запросе (пакет 386) появляется новое поле - заголовок Authorization. Этот заголовок отсутствует в первом запросе (пакет 246). Заголовок Authorization используется для передачи учетных данных пользователя серверу для аутентификации.
     ![image](https://github.com/user-attachments/assets/f61567ea-7f4c-40d0-b81a-60240b83593f)
